<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
<title>Hollow Creek — Demo corregido (1024)</title>
<style>
  :root{--hud-bg: rgba(0,0,0,0.45); --hud-color:#eaeaea}
  html,body{height:100%;margin:0;background:#000;color:var(--hud-color);font-family:monospace; -webkit-tap-highlight-color: transparent;}
  #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  canvas{display:block; width:100vmin; height:100vmin; max-width:100vw; max-height:100vh; touch-action:none; -webkit-user-select:none; image-rendering: optimizeSpeed; background:#000}
  #ui { position:fixed; left:12px; top:12px; z-index:20; pointer-events:none; }
  .stat { background:var(--hud-bg); color:var(--hud-color); padding:6px 8px; margin-bottom:6px; border-radius:6px; font-size:13px; }
  #startOverlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:40; }
  #startOverlay .card { background:rgba(0,0,0,0.75); color:#fff; padding:20px 28px; border-radius:10px; text-align:center; font-size:20px }
  #loading { position:fixed; left:50%; top:10px; transform:translateX(-50%); z-index:50; background:rgba(0,0,0,0.65); padding:6px 10px; border-radius:8px; font-size:13px }
  @media (orientation:landscape) {
    canvas{ width:100vw; height:100vh; }
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="gameCanvas" width="1024" height="1024" aria-label="Hollow Creek game canvas"></canvas>
</div>

<div id="ui" aria-hidden="true">
  <div class="stat" id="nightStat">Night: 1</div>
  <div class="stat" id="timeStat">12:00 AM</div>
  <div class="stat" id="powerStat">Power: 100%</div>
</div>

<div id="loading" style="display:none">Cargando assets...</div>

<div id="startOverlay">
  <div class="card">
    Toca para empezar<br/>
    <div class="hint">Audio y controles se habilitan con el primer toque</div>
  </div>
</div>

<script>
/* ---------- Hollow Creek — Demo corregido (1024) ---------- */
/* Cambios principales:
 - grilla muestra todas las cámaras (fallback si falta imagen)
 - animatrónicos minimal (movimiento + entrada a oficina)
 - scanlines con opacity 0.12 (menos intrusivo)
 - oficina dibujada incluso si falta la imagen
 - logs de assets faltantes
*/

/* Canvas y estado */
const CANVAS = document.getElementById('gameCanvas');
const ctx = CANVAS.getContext('2d');
ctx.imageSmoothingEnabled = false;
const W = CANVAS.width, H = CANVAS.height;

const UI = {
  night: document.getElementById('nightStat'),
  time: document.getElementById('timeStat'),
  power: document.getElementById('powerStat'),
  loading: document.getElementById('loading'),
  startOverlay: document.getElementById('startOverlay')
};

let started = false;
let monitorOpen = false;
let monitorSingle = null;
let night = 1, hour = 0, power = 100;
let cassidyActive = false;
let cassidyGlitch = { next:0, active:false, end:0 };
let doorLeftClosed=false, doorRightClosed=false;

const assets = { imgs: {}, audios: {} };

/* Paths: intenta jpg para cams y png para sprites/overlays */
function tryCamPath(baseName){
  return [
    `assets/cams/${baseName}.jpg`,
    `assets/cams/${baseName}.png`
  ];
}
function pathFor(name){
  if(name.startsWith('cam') || name.startsWith('office')) return tryCamPath(name);
  if(name.startsWith('door') || name==='scanlines' || name.startsWith('cassidy') || name.startsWith('menu') || name.startsWith('cursor')) return [`assets/${name}.png`,`assets/${name}.jpg`];
  // animatronics expected in assets/animatronics as png
  return [`assets/animatronics/${name}.png`,`assets/animatronics/${name}.jpg`];
}

/* Load with fallbacks */
function loadImageKey(key){
  const paths = pathFor(key);
  return new Promise(resolve=>{
    (function tryOne(i){
      if(i >= paths.length){ console.warn('Missing image', key); resolve(null); return; }
      const img = new Image();
      img.onload = ()=>{ assets.imgs[key]=img; resolve(img); };
      img.onerror = ()=> { tryOne(i+1); };
      img.src = paths[i];
    })(0);
  });
}
function loadAudioKey(key, path){
  return new Promise(resolve=>{
    const a = new Audio();
    a.preload='auto';
    a.src=path;
    a.oncanplaythrough = ()=>{ assets.audios[key]=a; resolve(a); };
    a.onerror = ()=>{ console.warn('Missing audio', key, path); resolve(null); };
  });
}

/* Camera keys */
const CAM_KEYS = ['cam1_salon_base','cam2_baby_base','cam3_mini_base','cam4_kitchen_base','cam5_bath_base','cam6_storage_base','office_base_closed','office_open'];

/* Animatrónicos definitions (light FSM) */
const animDefs = {
  vale:{allowed:[1,3,5], start:1, color:'#d9b300', baseInterval:25000, activeFrom:3},
  patch:{allowed:[1,2,4], start:1, color:'#6fb0ff', baseInterval:28000, activeFrom:2},
  lulla:{allowed:[1,3,4,5], start:1, color:'#ff7fa1', baseInterval:32000, activeFrom:1},
  rust:{allowed:[6], start:6, color:'#9b6e44', baseInterval:42000, activeFrom:5}
};
const anims = {};
Object.keys(animDefs).forEach(k=>{
  anims[k] = {
    name:k,
    cam:animDefs[k].start,
    lastMove:Date.now(),
    baseInterval:animDefs[k].baseInterval,
    inOffice:false,
    active:false,
    lastSeen:Date.now()
  };
});

/* audio map (reducida) */
const AUDIO_PATHS = {
  amb_night_loop: 'audio/amb_night_loop.mp3',
  crt_static_loop: 'audio/crt_static_loop.mp3',
  crt_open: 'audio/crt_open.mp3',
  crt_close: 'audio/crt_close.mp3',
  door_open: 'audio/door_open.mp3',
  door_close: 'audio/door_close.mp3',
  step_heavy: 'audio/step_heavy.mp3',
  jumpscare_vale: 'audio/jumpscare_vale.mp3',
  cassidy_static_hit: 'audio/cassidy_static_hit.mp3',
  phone_night1: 'audio/phone_night1.mp3',
  cam_switch: 'audio/cam_switch.mp3'
};

/* preload all (images + audio) */
async function preloadAll(){
  UI.loading.style.display = 'block';
  const imgKeys = [...CAM_KEYS,
    'door_left_sprite','door_right_sprite',
    'scanlines','cassidy_static','menu_crt','cursor_double',
    // anim sprites (try to load; may be missing)
    'vale_idle','patch_idle','lulla_idle','rust_idle'
  ];
  const promises = imgKeys.map(k => loadImageKey(k));
  const audioPromises = Object.entries(AUDIO_PATHS).map(([k,p]) => loadAudioKey(k,p));
  await Promise.all([...promises, ...audioPromises]);
  // log which cams/images are missing for debug
  CAM_KEYS.forEach(k => { if(!assets.imgs[k]) console.warn('cam missing:', k); });
  ['door_left_sprite','door_right_sprite','scanlines','cassidy_static'].forEach(k=>{ if(!assets.imgs[k]) console.warn('overlay missing:', k); });
  UI.loading.style.display = 'none';
}

/* start after user gesture */
async function startGame(){
  if(started) return;
  started = true;
  UI.startOverlay.style.display = 'none';
  await preloadAll();
  if(assets.audios.amb_night_loop){ assets.audios.amb_night_loop.loop = true; assets.audios.amb_night_loop.volume = 0.12; assets.audios.amb_night_loop.play().catch(()=>{}); }
  if(assets.audios.crt_static_loop){ assets.audios.crt_static_loop.loop = true; assets.audios.crt_static_loop.volume = 0.06; assets.audios.crt_static_loop.play().catch(()=>{}); }
  // init anims activation by night
  Object.keys(anims).forEach(k => anims[k].active = (night >= animDefs[k].activeFrom));
  // hour ticker
  setInterval(()=>{
    if(!started) return;
    hour++;
    if(hour > 7){ night = Math.min(7, night+1); hour = 0; }
    power = Math.max(0, power - Math.floor(Math.random()*6));
    UI.night.innerText = 'Night: ' + night;
    UI.time.innerText = (hour===0?'12:00 AM':(hour + ':00 AM'));
    // update anims active flag
    Object.keys(anims).forEach(k=> anims[k].active = (night >= animDefs[k].activeFrom));
    cassidyActive = (night >= 4);
  }, 90000); // 90s per hour

  // schedule first cassidy glitch
  cassidyGlitch.next = Date.now() + 8000 + Math.random()*8000;

  requestAnimationFrame(loop);
}

/* helper: draw placeholder */
function drawPlaceholderRect(x,y,w,h,label){
  ctx.fillStyle = '#070707';
  ctx.fillRect(x,y,w,h);
  ctx.strokeStyle = '#2b2b2b';
  ctx.strokeRect(x+2,y+2,w-4,h-4);
  ctx.fillStyle = '#9a9a9a';
  ctx.font = '18px monospace';
  ctx.fillText(label, x+12, y+26);
}

/* Draw office even if image missing */
function drawOfficeView(){
  const officeImg = assets.imgs['office_base_closed'];
  if(officeImg){
    ctx.drawImage(officeImg, 0, 0, W, H);
  } else {
    // procedural office placeholder: desk + two doors closed/circles to show
    ctx.fillStyle = '#0b0b0b';
    ctx.fillRect(0,0,W,H);
    // desk
    ctx.fillStyle = '#1c1c1c';
    ctx.fillRect(W*0.22, H*0.55, W*0.56, H*0.14);
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(W*0.24, H*0.57, W*0.12, H*0.10);
    // doors (left / right)
    ctx.fillStyle = doorLeftClosed ? '#4b3f2f' : '#0c0c0c';
    ctx.fillRect(W*0.05, H*0.28, W*0.16, H*0.44);
    ctx.fillStyle = doorRightClosed ? '#4b3f2f' : '#0c0c0c';
    ctx.fillRect(W*0.79, H*0.28, W*0.16, H*0.44);
    // label
    ctx.fillStyle = '#bbb';
    ctx.font = '20px monospace';
    ctx.fillText('Office (missing office_base_closed)', 24, 34);
  }
  // draw office in-office anims
  Object.values(anims).forEach(a=>{
    if(a.inOffice){
      // try sprite jumpscare if exists
      const spriteKey = a.name + '_jumpscare';
      const sprite = assets.imgs[spriteKey];
      if(sprite){
        // draw centered near desk
        ctx.drawImage(sprite, W*0.36, H*0.32, W*0.28, H*0.48);
      } else {
        // silhouette
        ctx.fillStyle = a.color || '#fff';
        ctx.fillRect(W*0.44, H*0.45, W*0.12, H*0.28);
        ctx.fillStyle = '#000';
        ctx.font = '18px monospace';
        ctx.fillText(a.name.toUpperCase(), W*0.445, H*0.43);
      }
    }
  });
}

/* Monitor grid */
const thumbW = Math.floor(W*0.28), thumbH = Math.floor(H*0.22);
const camPositions = [
  {x: W*0.05, y: H*0.06, id:1},
  {x: W*0.37, y: H*0.06, id:2},
  {x: W*0.69, y: H*0.06, id:3},
  {x: W*0.05, y: H*0.33, id:4},
  {x: W*0.37, y: H*0.33, id:5},
  {x: W*0.69, y: H*0.33, id:6},
  {x: W*0.37, y: H*0.60, id:7}
];

function drawMonitorGrid(){
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);
  camPositions.forEach(p=>{
    const rx = Math.floor(p.x), ry = Math.floor(p.y);
    const key = (p.id === 7 ? 'office_base_closed' : 'cam' + p.id + '_salon_base');
    const img = assets.imgs[key];
    if(img) ctx.drawImage(img, rx, ry, thumbW, thumbH);
    else drawPlaceholderRect(rx, ry, thumbW, thumbH, 'CAM ' + p.id);
    // if any anim present on that cam, draw dot
    Object.values(anims).forEach(a=>{
      if(a.active && !a.inOffice && a.cam === p.id){
        // draw small colored circle
        ctx.beginPath();
        ctx.fillStyle = a.color || '#f00';
        ctx.arc(rx + thumbW - 24, ry + 24, 10, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.font = '10px monospace';
        ctx.fillText(a.name, rx + 6, ry + 18);
      }
    });
    ctx.fillStyle = '#ccc';
    ctx.font = '14px monospace';
    ctx.fillText('CAM ' + p.id, rx + 8, ry + 18);
  });
}

function drawSingleCam(id){
  const key = (id === 7 ? 'office_base_closed' : 'cam' + id + '_salon_base');
  const img = assets.imgs[key];
  if(img) ctx.drawImage(img, 0, 0, W, H);
  else drawPlaceholderRect(0,0,W,H,'CAM ' + id + ' (missing asset)');
  // mark anims that are on this cam (non-office)
  Object.values(anims).forEach(a=>{
    if(a.active && !a.inOffice && a.cam === id){
      // draw big silhouette on single cam
      const px = W*0.65, py = H*0.42;
      const sprite = assets.imgs[a.name + '_idle'];
      if(sprite){
        ctx.drawImage(sprite, px - 80, py - 140, 160, 300);
      } else {
        ctx.fillStyle = a.color || '#fff';
        ctx.fillRect(px - 32, py - 80, 64, 140);
        ctx.fillStyle='#000'; ctx.font='16px monospace';
        ctx.fillText(a.name, px - 28, py - 90);
      }
    }
  });
}

/* scanlines overlay (reduced alpha) */
function drawScanlines(){
  const sl = assets.imgs['scanlines'];
  if(sl){
    ctx.globalAlpha = 0.12; // reducido
    ctx.drawImage(sl, 0, 0, W, H);
    ctx.globalAlpha = 1;
    return;
  }
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = '#000';
  for(let y=2;y<H;y+=2) ctx.fillRect(0,y,W,1);
  ctx.restore();
}

/* Cassidy overlay (static) */
function updateCassidy(now){
  if(!cassidyActive) return;
  if(now > cassidyGlitch.next && !cassidyGlitch.active){
    cassidyGlitch.active = true;
    cassidyGlitch.end = now + (1200 + Math.random()*1400);
    cassidyGlitch.next = now + (8000 + Math.random()*15000);
  }
  if(cassidyGlitch.active && now > cassidyGlitch.end) cassidyGlitch.active = false;
}
function drawCassidyOverlay(){
  if(!cassidyActive) return;
  const img = assets.imgs['cassidy_static'];
  if(cassidyGlitch.active && img){
    ctx.globalAlpha = 0.45;
    ctx.drawImage(img, 0, 0, W, H);
    ctx.globalAlpha = 1;
    if(assets.audios.cassidy_static_hit) try{ assets.audios.cassidy_static_hit.play(); }catch(e){}
  } else if(cassidyGlitch.active){
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    for(let i=0;i<220;i++) ctx.fillRect(Math.random()*W, Math.random()*H, 1, 1);
  }
}

/* ANIMATION / AI */
function updateAI(now){
  Object.values(anims).forEach(a=>{
    a.active = (night >= animDefs[a.name].activeFrom);
    if(!a.active) return;
    if(a.inOffice) return;
    // move every baseInterval scaled by night difficulty
    const nightScale = 1 - Math.min(0.6, (night-1)*0.08);
    const interval = Math.max(900, a.baseInterval * nightScale);
    if(now - a.lastMove > interval){
      // pick random allowed cam (may stay)
      const arr = animDefs[a.name].allowed;
      a.cam = arr[Math.floor(Math.random()*arr.length)];
      a.lastMove = now;
      a.lastSeen = now;
    }
    // if monitor open and showing either grid or single view, update lastSeen
    if(monitorOpen){
      if(monitorSingle === null){
        a.lastSeen = now;
      } else if(a.cam === monitorSingle){
        a.lastSeen = now;
      }
    }
    // Rust unseen rule -> office
    if(a.name === 'rust'){
      if(now - a.lastSeen > 30000 && !a.inOffice){
        a.inOffice = true;
        triggerEntry(a.name);
      }
    }
    // entry rules for others (Vale on cam3 and door right open -> enters)
    if(a.name === 'vale' && a.cam === 3 && !doorRightClosed){
      a.inOffice = true; triggerEntry('vale');
    }
    if(a.name === 'patch' && a.cam === 6 && !doorLeftClosed){
      a.inOffice = true; triggerEntry('patch');
    }
    if(a.name === 'lulla' && a.cam === 3 && !doorRightClosed){
      // lulla has smaller window: if lastMove very recent -> entry
      if(Date.now() - a.lastMove < interval * 0.5){
        a.inOffice = true; triggerEntry('lulla');
      }
    }
  });
}

function triggerEntry(name){
  // simple jumpscare: set anim inOffice; play sound
  console.log('ENTRY triggered by', name);
  if(assets.audios['jumpscare_' + name]) try{ assets.audios['jumpscare_' + name].play(); }catch(e){}
  // mark the anim as inOffice (already set), will render in office
  // after 2.5s reset that anim to not inOffice for demo
  setTimeout(()=>{ if(anims[name]) { anims[name].inOffice = false; anims[name].lastMove = Date.now(); } }, 2500);
}

/* loop */
function loop(ts){
  ctx.clearRect(0,0,W,H);

  if(!monitorOpen){
    drawOfficeView();
  } else {
    if(monitorSingle !== null) drawSingleCam(monitorSingle);
    else drawMonitorGrid();
  }

  // update AI + Cassidy
  updateAI(Date.now());
  updateCassidy(Date.now());
  drawCassidyOverlay();

  // overlays
  drawScanlines();

  // small HUD overlay on canvas
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(8,8,260,64);
  ctx.fillStyle = '#ddd';
  ctx.font = '18px monospace';
  ctx.fillText('Night: ' + night, 16, 30);
  ctx.fillText((hour===0?'12:00 AM':(hour + ':00 AM')), 16, 54);

  requestAnimationFrame(loop);
}

/* Input */
function getCanvasCoords(clientX, clientY){
  const rect = CANVAS.getBoundingClientRect();
  const scaleX = CANVAS.width / rect.width;
  const scaleY = CANVAS.height / rect.height;
  return { x: Math.floor((clientX - rect.left) * scaleX), y: Math.floor((clientY - rect.top) * scaleY) };
}

function handleTap(x,y){
  if(!started){ startGame(); return; }
  if(y > H * 0.80){
    monitorOpen = !monitorOpen;
    if(monitorOpen){ if(assets.audios.crt_open) try{ assets.audios.crt_open.play(); }catch(e){} }
    else { if(assets.audios.crt_close) try{ assets.audios.crt_close.play(); }catch(e){} monitorSingle = null; }
    return;
  }
  if(monitorOpen){
    for(const p of camPositions){
      const rx = Math.floor(p.x), ry = Math.floor(p.y);
      if(x >= rx && x <= rx + thumbW && y >= ry && y <= ry + thumbH){
        monitorSingle = p.id;
        if(assets.audios.cam_switch) try{ assets.audios.cam_switch.play(); }catch(e){}
        return;
      }
    }
    monitorSingle = null;
    return;
  }
  // doors
  if(x < W*0.5){
    doorLeftClosed = !doorLeftClosed;
    if(doorLeftClosed){ if(assets.audios.door_close) try{ assets.audios.door_close.play(); }catch(e){} }
    else { if(assets.audios.door_open) try{ assets.audios.door_open.play(); }catch(e){} }
  } else {
    doorRightClosed = !doorRightClosed;
    if(doorRightClosed){ if(assets.audios.door_close) try{ assets.audios.door_close.play(); }catch(e){} }
    else { if(assets.audios.door_open) try{ assets.audios.door_open.play(); }catch(e){} }
  }
}

CANVAS.addEventListener('click',(ev)=>{ const p = getCanvasCoords(ev.clientX, ev.clientY); handleTap(p.x,p.y); });
CANVAS.addEventListener('touchstart',(ev)=>{ ev.preventDefault(); const t = ev.touches[0]; const p = getCanvasCoords(t.clientX,t.clientY); handleTap(p.x,p.y); },{passive:false});
UI.startOverlay.addEventListener('click',()=>startGame()); UI.startOverlay.addEventListener('touchstart',()=>startGame(),{passive:false});

/* expose for debug */
window._assets = assets;
window._anims = anims;
window._toggleMonitor = ()=>{ monitorOpen = !monitorOpen; };
window._setNight = (n)=>{ night = n; }

requestAnimationFrame(loop);
</script>
</body>
</html>
